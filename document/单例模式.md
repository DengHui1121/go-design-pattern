# 单例模式 Singleton Design Pattern

**概念：** 一个类只允许创建一个对象，那么这个类就是单例类，该模式就是单利设计模式

**使用场景：**避免资源访问冲突、业务概念上全局唯一

**唯一性：**进程唯一

**进程唯一、线程唯一、集群唯一的区别和实现方式**

- 区别：
  - 进程唯一：进程内唯一、进程间不唯一
  - 线程唯一：线程内唯一、线程间不唯一
  - 集群唯一：集群相当于多个进程构成的集合。进程内唯一、进程间唯一
- 实现方式
  - 线程唯一：通过创建一个HashMap，线程id作为key，但是在Go语言中采用协程，且并没有返回协程id
  - 集群唯一：将单例对象序列化并存储大外部共享存储区(文件)，使用时先读取，并反序列化在使用，使用完再存储到共享区

**如何实现**

- 构造函数需要私有访问权限，避免外部创建实例
- 考虑对象创建时的现成安全问题
- 考虑是否支持延迟加载
- 考虑获取实例函数`getInstance()`性能是否高(是否加锁)

**分类：** 

- 饿汉式
  - 类加载时，静态实例就已经创建并初始化
  - 实例创建过程现成安全
  - 不支持延迟加载
  - 实例占用资源多、初始化耗时长
- 懒汉式
  - 在`getInstance()`才去创建实例和初始化
  - 获取实例时需要加锁
  - 支持延迟加载
  - 不支持高并发
- 双重检测
  - 在懒汉式基础上，实现类级别锁
  - 获取实例时，无需每次进行加锁解锁
  - 静态内部类的方式，更简单实现双重检测
  - 枚举类型

**存在的问题**

- 对OOP特性不友好
  - 抽象-违背了基于接口而非实现的设计原则
  - 继承
  - 多态
- 隐藏类之间的依赖关系
  - 降低代码可读性
  - 构造函数、参数传递的方式生命的类之间的依赖关系，清晰明了；相反单例类不需要显示创建、参数传递，直接调用
  - **将单例生成的对象作为参数传递给函数**
- 代码扩展性不好
  - 例如：某些sql语句执行慢，会影响其他sql，使用新链接隔离慢sql
- 影响代码可测试性
  - 硬编码模式不利于mock，导致无法实现mock替换
  - 成员变量可修改，测试时需要主席不同测试用例之间的相互影响
  - **可以通过将单例类作为参数传递给需要使用的方法解决可测试问题**
- 不支持有参数的构造函数

**扩展；多例模式**

一个类可以创建多个对象，但是个数是有限制的。

